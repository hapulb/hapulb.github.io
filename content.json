{"meta":{"title":"poor Branson","subtitle":null,"description":null,"author":"poor Branson","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-12T11:00:24.000Z","updated":"2018-01-12T11:01:28.284Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-12T10:54:51.000Z","updated":"2018-01-12T11:09:08.331Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"first"}],"posts":[{"title":"闲着翻译了EasyRTC的官方教程","slug":"EasyRTC","date":"2018-01-13T09:56:23.000Z","updated":"2018-01-14T02:16:18.939Z","comments":false,"path":"2018/01/13/EasyRTC/","link":"","permalink":"http://yoursite.com/2018/01/13/EasyRTC/","excerpt":"","text":"概览EasyRTC基于webRTC。WebRTC是W3C/IETF用于浏览器间实时音视频沟通以及数据传输的一个实现方案。WebRTC只需要一个轻量负荷的服务器就可以支持点对点(P2P)间的任何数据传输。 EasyRTC由客户端（浏览器端）的JS库与基于node.js的后端服务器组成。WebRTC已经被各个浏览器(google chrome, firefox, opera, etc)所支持，因此无需额外的浏览器插件。 Google Chrome对WebRTC的API有着最广泛的支持，Opera现在采用与Chrome相同的内核引擎，因此所有API行为与chrome基本一致。Firefox对WebRTC的Data Channel有着十分良好的实现，但仅提供了基础的视频功能。 一旦WebRTC被标准化，它将有着巨大的潜能为音视频会议，多用户游戏，以及许多其他的基于音视频，数据传输的应用提供支持。 如同其他的软件，强大的功能往往伴随着复杂的内部实现。WebRTC有着十分曲折的学习曲线，对开发人员不够友好。为了简化具体的开发流程，我们（Priologic）构建了EasyRTC框架。 构建一个基于WebRTC的应用通常有如下步骤。 将本地摄像头、麦克风获取到的数据输出成media stream对象 与信令服务器建立连接 通过浏览器与目标用户建立p2p通信 将media stream绑定到 通过使用EasyRTC，一些步骤可以被简化到一个简单的通信(call)当中，能极大地简化开发流程，尤其是当开发人员需要投入更多的精力于多平台支持当中。 此文档是编写基于WebRTC应用的一个基本教程，但并未包含EasyRTC的所有API。 术语 callbakck（回调函数） Media Stream 浏览器音视频输出对象 Peer Connection 点对点连接 Server 安装EasyRTC与获取支持EasyRTC的安装十分简单，多数平台可在10分钟内完成。我们提供了Windows，Linux，Mac的安装向导。EasyRTC的源码可在[https://github.com/priologic/easyrtc]获取。在doc目录下可以获取到客户端与服务端的所有HTML说明文档 视频会议html 略 页面载入完成(onload)后调用初始化函数(initialization function)。初始化函数的最主要作用是调用EasyRTC.easyApp方法。该方法有如下参数 applicationName - String 应用名，如”Company_Chat_Line” self-video-id - String video标签id array-of-caller-video-ids - Array 包含了其他用户（除当前用户）的video标签id successCallback - 连接成功时回调函数 初始化函数可以使用EasyRTC.setRoomOccupantListener来注册一个回调函数，以用于获取当前已连接到同一房间内的其他用户id，。 示例： 123456function my_init() &#123; easyrtc.setRoomOccupantListener(loggedInListener) easyrtc.easyApp(\"Company_chat_line\", \"self\", [\"caller\"], id =&gt; &#123; console.info(\"My id is \" + id) &#125;)&#125; 当用户从”Company_chat_line”连接或断开链接时，easyrtc.setRoomOccupantListener将被调用，该方法的回调函数包含两个参数: String room name Array 连接到相同房间名的用户id 在我们的示例程序当中，该方法的回调函数将建立一系列用于“拨打”给当前已连接到房间内的其他用户的按钮。 html 略 多数情况下可以忽略room_name参数，除非你的应用允许用户同时连接到多个房间。 在现实的应用当中，我们不会使用easyrtc的默认id当作按钮的label属性。我们将使用类似姓名，职位等建立起与easyrtc id相关联的内容以用作按钮的label属性。 初始化一个call，我们只需要调用 easyrtc.call 方法，传入目标用户的id，该方法包含三个回调函数： successCallback(id) errorCallback(errorCode, errorText) accepted(wasAccepted, id) 指明该call是否被接受 示例代码： 123456789function performCall(id) &#123; easyrtc.call(id, id =&gt; &#123; console.info(\"completed call to \" + id) &#125;, errorMessage =&gt; &#123; console.error(\"err: \" + errorMessage) &#125;, (accepted, bywho) =&gt; &#123; console.info(accepted ? \"accepted\" : \"rejected\" + \" by \" + bywho) &#125;)&#125; html 略 视频会议(Advanced)在上一节，我们大致地描述了构建一个视频会议应用的最简单情形。在这一节，我们将进一步深入。 除了调用easyrtc.easyApp，你也可以调用easyrtc.initMediaSource来直接获取本地设备的media stream，成功之后可以调用easyrtc.connect方法来连接到信令服务器。这也是easyrtc.easyApp的内部实现。 html略 注意: easyrtc.getLocalStream和easyrtc.setVideoObjectSrc，前者用于当easyrtc.initMediaSource调用完成，从本地摄像头和麦克风获取media stream，后者用于将media stream与video标签绑定。一起使用便可以十分便携地供用户实时观察到他们自己的图像。 我们还需要两个其他函数 一个用于提供远程用户的media stream 1234easyrtc.setStreamAcceptor((callerId, stream) =&gt; &#123; let video = document.getElementById(\"caller\") easyrtc.setVideoObjectSrc(video, stream)&#125;) 一个用于检测远程用户是否挂起（离线）。该函数用于清除对应的video标签 123easyrtc.setOnStreamClosed(callerId =&gt; &#123; easyrtc.setVideoObjectSrc(document.getElementById(\"caller\"), \"\")&#125;) 整个js文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 设置远程用户的media stream 的关联video标签easyrtc.setStreamAcceptor((callerId, stream) =&gt; &#123; let video = document.getElementById(\"caller\") // 绑定media stream到video标签对象 easyrtc.setVideoObjectSrc(video, stream)&#125;)// 当远程media strem 关闭easyrtc.setOnStreamClosed(callerId =&gt; &#123;// 清除关联的video标签内容easyrtc.setVideoObjectSrc(document.getElementById(\"caller\"), \"\")&#125;)// 初始化函数function my_init() &#123; // 设置监听器，获取当前在线的用户 easyrtc.setRoomOccupantListener(loggedInListener) // 连接成功处理函数 let connectSuccess = myId =&gt; &#123; console.info(\"My easyrtc id is \" + myId) &#125; // 连接失败 创建本地media stream对象失败时调用函数 let connectFailure = (errorCode, errText) =&gt; &#123; console.error(errText) &#125; // 初始化本地media stream easyrtc.initMediaSource(() =&gt; &#123; let selfVideo = document.getElementById(\"self\") // 绑定本地media stream 到video tag easyrtc.setVideoObjectSrc(selfVideo, easyrtc.getLocalStream()) // 连接到服务器 easyrtc.connect(\"Company_Chat_line\", connectSuccess, connectFailure) &#125;, connectFailure)&#125;// 当获取到当前房间内在线用户function loggedInListener(roomName, otherPeers) &#123; let otherClientDiv = document.getElementById(\"otherClients\") while(otherClientDiv.hasChildNodes()) &#123; // 移除最后一个 “text ”otherClientDiv.removeChild(otherClientDiv.lastChild) &#125; for (let i in otherPeers) &#123; let button = document.createElement(\"button\") // 为每一个远程用户创建一个按钮监听器 button.onclick = easyrtcId =&gt; &#123; // 发起连接 return (easyrtcId) =&gt; performCall(easyrtcId) &#125;(i) let label = document.createTextNode(i) button.appendChild(label) otherClientDiv.appendChild(button) &#125;&#125;function performCall(id) &#123; easyrtc.call(id, id =&gt; &#123; console.info(\"completed call to \" + id) &#125;, (errorCode, errText) =&gt; &#123; console.error(\"err: \" + errorText) &#125;, (accepted, bywho) =&gt; &#123; console.info(accepted ? \"accepted\" : \"rejected\" + \" by \" + bywho) &#125;)&#125; 使用多个本地media stream源使用多个media stream的基本思想是，你需要为每个media stream命名。当你调用initMediaSource，它的第三个参数便是media stream的名字，如： 1easyrtc.initMediaStream(success, failure, yourname) 如果你没有传入第三个参数，则该media stream会得到一个默认的”default”。 使用easyrtc.getLocalMediaIds以获取所有本地media stream的名字 12let ids = easyrtc.getLocalMediaIds()ids.map(id =&gt; console.info(id)) 当你初始化一个call，可以传入一个stream name的数组作为第五个参数，同样的，当你接受call时，你可以传入一个stream name的数组作为accept回调函数的第二个参数。 12345easyrtc.call(otherEasyrtcId, successCB, failCB, wasAcceptedCB, [\"first_name\", \"second_name\", \"etc\"])easyrtc.setAcceptChecker((otherGuy, acceptCallback) =&gt; &#123; acceptCallback(true, [\"first_name\", \"second_name\"])&#125;) 你也可以通过使用easyrtc.addStreamToCall向一个已存在的call添加meida stream。该方法接受三个参数，接受stream的id，stream的名字，以及一个optional的回调处理函数。 注意：EasyApp 框架并不是专门为多media stream而设计的。它的初衷便是假定只有单个本地media stream。如果你想使用media stream，那么你就必须自己将这些media stream绑定到video标签。 屏幕分享只使用音频或视频功能拒绝远程对话(call)EasyRTC允许注册一个在用户每次收到call时都将被调用的函数。该函数接受远程用户的id，以及一个报告函数(reporting function)作为参数，报告函数接受一个参数，true接受对话，false拒绝对话。 12345678910111213easyrtc.setAcceptChecker( function(easyrtcid, acceptor)&#123; if( easyrtc.idToName(easyrtcid) === 'Fred' )&#123; acceptor(true); &#125; else if( easyrtc.idToName(easyrtcid) === 'Barney' )&#123; setTimeout( function()&#123; acceptor(true, ['myOtherCam']); // myOtherCam presumed to a streamName &#125;, 10000); &#125; else&#123; acceptor(false); &#125; &#125;); 加入或离开房间Room是EasyRTC的一个隔离（compartmentalize）功能，目的是为用户建立起一个个“chat rooms”。房间的行为受服务器安装的EasyRTC Server的配置所影响（详见服务器模块文档）。默认行为如下： 除非用户在连接前指定了所要加入的房间名，否则将会加入默认的“default”房间。 一个用户可以是多个房间的成员 每个用户所加入的任一个房间发生变化时（用户的加入，离开），都会触发roomOccupantListener函数 加入一个不存在的房间将会创建它 加入房间 1easyrtc.joinRoom(roomName, roomParameters, successCallback, failureCallback) 其中，roomParameters是Application specific（不详），可以为空。joinRoom可以在任何时候调用任意多次，但successCallback, failureCallback只会在成功与信令服务器建立连接之后才会被调用。 离开房间 1easyrtc.leaveRoom(roomName, successCallback, failureCallback) leaveRoom的性质同joinRoom 监听Error你可以通过easyrtc.setOnError注册一个error callback用以处理错误。该函数接受一个形如{“errorCode”: “errorCode”, “errorText”: “errorText”}的对象。 123easyrtc.setOnError(errEvent =&gt; &#123; console.error(errEvent.errorText)&#125;) 发送消息你可以通过调用easyrtc.sendDataWS来使用websocket通信， 12345678easyrtc.sendDataWS(destination, messageType, messageData, ackHandler)easyrtc.sendDataWS(\"xkxkxkxkxk9c93\", \"contactInfo\", &#123;firstName: \"jack\", lastName: \"smith\"&#125;, ackMsg =&gt; &#123;// ackMsg 为来自服务器的确认信息 if (ackMsg.msgType === \"error\") &#123; console.error(ackMsg.msgData.errorText) &#125;&#125;) 注意: 通过websocket通信意味着你指定信息要通过服务器转发 destination 可以是peer的id，或者是一个指定了一个或多个目标id的js对象，或者房间（详见文档）。messageType需要自行指定，ackHandler处理来自服务器的确认信息 处理来自其他用户的信息:easyrtc.setPeerListener((sender_id, msgType, msgData, targeting) =&gt; { if (msgType === “contactInfo”) { console.info(sender_id + “ is named “ + msgData.firstName + “ “ + msgData.lastName) }}) 其中，当使用WebRTC的data channel发送数据时，targeting为null，否则为{targetEasyrtcid, targetGroup, targetRoom}当中的一个。 你也可以为特定的msgType或sender指定监听器，在这种情况下，每次将只有一个监听器会被调用，指定的监听器将被优先调用。 使用Data Channels在使用data channel之前，发送者和接收者都必须启用data channels。 1easyrtc.enableDataChannels(true) 之后便可监听与特定用户的datachannel的 ready 和 close 事件， 1234567easyrtc.setDataChannelOpenListener(sourceEasyrtcId =&gt; console.info(\"channel is open \"))easyrtc.setDataChannelCloseListener(sourceEasyrtcid =&gt; console.info(\"channel is close \")) open监听器被调用之后，便可以通过easyrtc.sendDataP2P来发送消息：1easyrtc.sendDataP2P(targetEasyrtcid, \"contactInfo\", &#123;firstName: \"jack\", lastName: \"smith\"&#125;) 监听data channels消息与websocket消息一致 获取当前连接数通过easyrtc.getConnectionCount来获取当前用户的连接数，该函数返回一个number 挂起通过easyrtc.hangup(peerId)来挂起与特定用户的连接 easyrtc.hangupAll()来挂起与所有用户的连接 与服务器断开链接1easyrtc.disconnect()","categories":[],"tags":[]},{"title":"Go Basic","slug":"Go Basic  ","date":"2018-01-03T07:34:24.000Z","updated":"2018-01-12T12:55:04.741Z","comments":false,"path":"2018/01/03/Go Basic  /","link":"","permalink":"http://yoursite.com/2018/01/03/Go Basic  /","excerpt":"","text":"packageEvery go program is consists of many packages which use the main func as the entry point.import package(import) 12345678import \"fmt\"import \"math\"``` ```goimport ( \"fmt\" \"math/rand\") exportvariable named with upper-case will automatically be exported 1fmt.Println(math.pi) //error occur, math.pi is undefined function Declaration 123func add(x int, y int) int &#123; return x + y&#125; this is the same as 123func add(x, y int) int &#123; return x + y&#125; multiple results 12345678func swap(x, y string) (string, string) &#123; return y, x&#125;func main() &#123; a, b := swap(\"hello\", \"world\") //single value assignment is not allowed fmt.Println(a, b)&#125; named return value it’s not recommanded to do like this in a complicated function 123456789func change(x, y int) (a, b int) &#123; b = x a = y return&#125;func main() &#123; fmt.Println(change(1, 5)) //return (5, 1)&#125; variable var keyword var could be used in function or packages 1234567891011package mainimport fmtvar c, python, javascript boolfunc main() &#123; var i int fmt.Println(i, c, python, javascript) //(0, false, false, false)&#125; initialize [initialize] 1var i, j int = 1, 2 or short-name variable declaration在函数外，所有statement都以一个关键字开头，因此 := 运算符只能在函数内使用，并且不能用做const变量声明 All statement begin with a keyword except in function, so the := operator only could be used inside function, the same as const variable 1234func main() &#123; var i, j int = 1, 2 k := 3&#125; variable type bool string int int8 int32 int64 uint uint8 uint32 uint64 uintptr byte// alias of uint8 rune// alias of int32 float32 float64 complex64 complex128 int, uint, uintptr 是根据系统位数“自适应”的，正常情况下应该使用int 类型转换 GO 必须显式地(explicitly)声明类型转换 12345678func main() &#123; i := 2 var j float64 = i//float64(i) fmt.Println(j)&#125;//error //cannot use i (type int) as type float64 in assignment pointer1var p *int this statement declare a pointer that only could point to type of int &amp; operator could get the address of a variable in the memory so, the statement bellow means create a pointer i point to a variable named x123456789101112131415161718192021var x int = 2var i *int = &amp;x``` **now we could use `*p` to get access to `x`**### struct&gt; A `struct` is a collection of fields* declaration ```gotype Vertex struct &#123; X int Y int&#125;func main() &#123; fmt.Println(Vertex&#123;1, 2&#125;)&#125; pointer in struct we could omit the * operator in struct 12345678910111213 type Vertex struct &#123; X int Y int&#125;func main() &#123; v := Vertex&#123;1, 2&#125; p := &amp;v p.X = 100 fmt.Println(v)&#125;//then we get &#123;100 2&#125; Arrays Declarationarray’s length is a part of property, so the length of an array could not be changed 123var a [10]intvar b = [3]int&#123;1, 2, 3&#125; Slice a slice like a references to arrays 1234567func main() &#123; arr := [3]int&#123;1, 2, 3&#125; var the_slice []int = arr[0:3] //or in short variable declare //the_slice := arr[0:3]&#125; a change to slice will affect the array 123456789func main() &#123; var arr = [3]int&#123;1, 2, 3&#125; the_slice := arr[1:2] the_slice[0] = 5 fmt.Println(arr) //print &#123;1 5 3&#125;&#125; type关键字 type 用来创建自定义数据类，或者创建已有数据类的别名 12345678type Vertex struct &#123; x float y float&#125;type myFloat float64var my myFloat","categories":[],"tags":[]},{"title":"use Redux and react-router-dom together","slug":"use Redux and react-router-dom together","date":"2017-09-06T00:45:23.000Z","updated":"2018-01-12T11:55:39.397Z","comments":false,"path":"2017/09/06/use Redux and react-router-dom together/","link":"","permalink":"http://yoursite.com/2017/09/06/use Redux and react-router-dom together/","excerpt":"","text":"phenomenonwrap one child component with Redux’s connect(), and wrap the returned value with Provider from react-redux. When the first time loading page, the content rendered by react-router-dom’s render property won’t display without any error.solutiondon’t use connect() in child component","categories":[],"tags":[]},{"title":"Cannot update during an existing state transition","slug":"Cannot update during an existing state transition","date":"2017-08-12T10:45:47.000Z","updated":"2018-01-12T13:00:03.769Z","comments":false,"path":"2017/08/12/Cannot update during an existing state transition/","link":"","permalink":"http://yoursite.com/2017/08/12/Cannot update during an existing state transition/","excerpt":"","text":"posible problem 传入子组件的父组件函数需要 1() =&gt; func() 以执行该函数","categories":[],"tags":[]},{"title":"Socket.io","slug":"Node Socket.io","date":"2017-06-15T11:35:23.000Z","updated":"2018-01-12T11:58:46.691Z","comments":false,"path":"2017/06/15/Node Socket.io/","link":"","permalink":"http://yoursite.com/2017/06/15/Node Socket.io/","excerpt":"","text":"Server sidebind to a http server(from module of http or third-party like Express) API new Server(httpServer[, options]) httpServer (http.Server) options(Object) path (string) namespace like /chat serveClient (boolean) whether to serve the client files … something more 1234567// if args of httpServer is undefined, //then a auto-created server will be usedconst io = require(\"socket.io\")()// orconst Server = require(\"socket.io\")const io = new Server()","categories":[],"tags":[]},{"title":"Redux","slug":"Redux","date":"2017-06-12T08:45:04.000Z","updated":"2018-01-12T11:54:34.707Z","comments":false,"path":"2017/06/12/Redux/","link":"","permalink":"http://yoursite.com/2017/06/12/Redux/","excerpt":"","text":"todo’s state struct12345678910111213&#123; todos: [ &#123; text: \"eat food\", completed: true &#125;, &#123; text: \"exercise\", completed: false &#125; ], visibilityFilter: \"SHOW_COMPLETED\"&#125; update the data in state we restrict that state could only be updated by dispatch an action. action action is normal javascript object, we could consider it as a description of specific handler 1234567891011121314[ &#123; type: \"ADD_TODO\", text: \"Go to swimming pool\" &#125;, &#123; type: \"TOGGLE_TODO\", index: 1 &#125;, &#123; type: \"SET_VISIBILITY_FILTER\", filter: \"SHOW_ALL\" &#125;] Reducerreducer is a function which return a new state after receiving state and action usually, we will create a lot of function to manage the state 123456789101112131415161718192021222324252627282930//manage visibilityFilterfunction visibilityFilter(action, state = \"SHOW_ALL\") &#123; if (action.type === \"SET_VISIBILITY_FILTER\") &#123; return action.filter &#125; else &#123; return state &#125;&#125;//manage actionfunction todos(action, state = []) &#123; switch (action.type) &#123; case \"ADD_TODO\": return state.concat([&#123; text: action.text, completed: false &#125;]) case \"TOGGLE_TODO\": return state.map((todo, index) =&gt; action.index === index ? &#123; text: todo.text, completed: !todo.completed &#125; : todo ) default: return state &#125;&#125; finally, we create a reducer to integrate both of them above 1234function todoApp(action, state = &#123;&#125;) &#123; todos: todos(action, state.todos), visibilityFilter: visibilityFilter(action, state.visibilityFilter)&#125; principle of Reduxsingle data sourcewhole app’s data is bind to a Object tree store is read-only reducer is pure-function pure-function pure-function is a function which return the same value if the parameter is the same","categories":[],"tags":[]},{"title":"Promise","slug":"Promise","date":"2017-05-12T02:24:48.000Z","updated":"2018-01-12T12:00:53.292Z","comments":false,"path":"2017/05/12/Promise/","link":"","permalink":"http://yoursite.com/2017/05/12/Promise/","excerpt":"","text":"several concept Promise 是异步编程的高级解决方案 简单来说，promise就是一个容器，里面保存着未来才会执行的事件 specialty 不受外界影响 有三种状态 pending fulfilled rejected，只有异步操作的结果可以决定这个状态，其他任何操作都无法改变 不变性 一旦状态确定，就不会再发生变化，任何时候都可以得到这个结果。 示例12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; if (/*async condition*/) &#123; resolve(value) &#125; else &#123; reject(error) &#125;&#125;)promise.then(value =&gt; &#123; console.info(value)&#125;, error =&gt; &#123; console.info(error)&#125;) resolve()将promise的状态从pending变为fulfilled， 并触发then()方法的第一个参数函数：reject()将promise从pending变为rejected，触发then()的第二个参数函数 promise 新建之后会立即执行 Promise.prototype.then() 该方法返回一个新的Promise对象，因此可以使用链式写法 1234promise.then(value =&gt; value, error =&gt; console.info(error)) .then(console.info(value)) .catch(e =&gt; console.error(e)) Promise.prototype.catch()该方法是then(null, rejection)的别名，在promise状态变为rejected之后会调用","categories":[],"tags":[]},{"title":"TCP [net]","slug":"Node TCP [net]","date":"2017-04-12T06:56:34.000Z","updated":"2018-01-12T11:57:26.363Z","comments":false,"path":"2017/04/12/Node TCP [net]/","link":"","permalink":"http://yoursite.com/2017/04/12/Node TCP [net]/","excerpt":"","text":"Server 创建 使用createServer([option], callback(socket))方法创建tcp服务器，option对象包含一个allowHalfOpen的bool属性，socket为端口的监听对象, 可以监听data事件12345const server = require(\"net\").createServer(socket =&gt; &#123; socket.on(\"data\", data =&gt; &#123; console.info(data.toString()) &#125;) &#125;) 监听 使用listen(port, [host], [callback])方法开始监听1server.listen(3000) 事件 listening connection error listening 该事件的回掉函数无任何参数1234server.on(\"listening\", () =&gt; &#123; console.info(\"server is listening on port 3000 ...\") console.info(server.address()) &#125;) connection 该事件的回掉函数传入新链接的socket对象，拥有data事件 123456 server.on(\"connection\", (socket) =&gt; &#123; console.info(\"new connections\") server.getConnections((err, count) =&gt; &#123; if (!err) console.info(count) &#125;)&#125;) error 1234server.on(\"error\", err =&gt; &#123; if (err.code === \"EADDRINUSE\") console.info(\"Address already in use\") else console.info(\"unknow error occurs\")&#125;) Client 创建 使用Socket()方法创建客户端","categories":[],"tags":[]}]}